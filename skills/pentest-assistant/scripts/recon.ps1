# Basic Reconnaissance Script (PowerShell)
# Usage: .\recon.ps1 target.com

param(
    [Parameter(Mandatory=$true)]
    [string]$Target
)

Write-Host "=== Reconnaissance for $Target ===" -ForegroundColor Green
Write-Host "Started: $(Get-Date)"
Write-Host ""

# Create output directory
$OutputDir = "recon-$Target"
New-Item -ItemType Directory -Path $OutputDir -Force | Out-Null
Set-Location $OutputDir

# DNS Enumeration
Write-Host "[*] DNS Enumeration..." -ForegroundColor Yellow
try {
    Resolve-DnsName $Target | Out-File dns.txt
    nslookup $Target 2>$null | Out-File dns.txt -Append
} catch {
    Write-Host "  DNS lookup failed or incomplete" -ForegroundColor Red
}

# Subdomain enumeration (simple approach)
Write-Host "[*] Subdomain Enumeration..." -ForegroundColor Yellow
$Subdomains = @("www", "mail", "ftp", "admin", "api", "blog", "shop", "test", "dev", "staging")
$FoundSubdomains = @()
foreach ($sub in $Subdomains) {
    $fullDomain = "$sub.$Target"
    try {
        $result = Resolve-DnsName $fullDomain -ErrorAction Stop
        $FoundSubdomains += $fullDomain
        Write-Host "  Found: $fullDomain" -ForegroundColor Green
    } catch {
        # Subdomain not found
    }
}
$FoundSubdomains | Out-File subdomains.txt

# Technology detection
Write-Host "[*] Technology Detection..." -ForegroundColor Yellow
try {
    $Response = Invoke-WebRequest -Uri "https://$Target" -Method Head -TimeoutSec 10
    $Response.Headers | Out-File headers.txt
    
    $Tech = @()
    if ($Response.Headers['Server']) { $Tech += "Server: $($Response.Headers['Server'])" }
    if ($Response.Headers['X-Powered-By']) { $Tech += "Powered-By: $($Response.Headers['X-Powered-By'])" }
    if ($Response.Headers['Via']) { $Tech += "Via: $($Response.Headers['Via'])" }
    $Tech | Out-File tech.txt
} catch {
    Write-Host "  Could not fetch headers" -ForegroundColor Red
}

# robots.txt and sitemap
Write-Host "[*] Checking robots.txt and sitemap..." -ForegroundColor Yellow
try {
    Invoke-WebRequest -Uri "https://$Target/robots.txt" -OutFile robots.txt -TimeoutSec 10
} catch {
    "robots.txt not found or inaccessible" | Out-File robots.txt
}

try {
    Invoke-WebRequest -Uri "https://$Target/sitemap.xml" -OutFile sitemap.xml -TimeoutSec 10
} catch {
    "sitemap.xml not found or inaccessible" | Out-File sitemap.xml
}

# Security headers check
Write-Host "[*] Analyzing Security Headers..." -ForegroundColor Yellow
$SecurityHeaders = @(
    "X-Frame-Options",
    "X-Content-Type-Options",
    "X-XSS-Protection",
    "Content-Security-Policy",
    "Strict-Transport-Security",
    "Referrer-Policy",
    "Permissions-Policy"
)

try {
    $Headers = (Invoke-WebRequest -Uri "https://$Target" -Method Head -TimeoutSec 10).Headers
    $SecurityResults = @()
    foreach ($header in $SecurityHeaders) {
        if ($Headers[$header]) {
            $SecurityResults += "✅ $header`: $($Headers[$header])"
        } else {
            $SecurityResults += "❌ $header`: Missing"
        }
    }
    $SecurityResults | Out-File security-headers.txt
    $SecurityResults | ForEach-Object { Write-Host "  $_" }
} catch {
    Write-Host "  Could not analyze security headers" -ForegroundColor Red
}

# SSL/TLS check (basic)
Write-Host "[*] SSL/TLS Check..." -ForegroundColor Yellow
try {
    $Cert = [System.Net.Security.SslStream]::new(
        [System.Net.Sockets.TcpClient]::new($Target, 443).GetStream(),
        $false,
        { param($sender, $certificate, $chain, $sslPolicyErrors) return $true }
    )
    # Note: This is a simplified check
    "SSL check completed - verify with sslscan or nmap for full details" | Out-File ssl-check.txt
} catch {
    "Could not verify SSL/TLS" | Out-File ssl-check.txt
}

# Return to original directory
Set-Location ..

Write-Host ""
Write-Host "=== Reconnaissance Complete ===" -ForegroundColor Green
Write-Host "Results saved in: $OutputDir\"
Write-Host "Finished: $(Get-Date)"

# Summary
Write-Host ""
Write-Host "Files created:" -ForegroundColor Cyan
Get-ChildItem $OutputDir | Select-Object Name, Length | Format-Table
